package gothriftpool

import (
	"bytes"
	"fmt"
	"github.com/koofr/gointerfacer"
	"go/format"
	"text/template"
)

const proxyTemplate = `// Autogenerated by gothriftpool generator
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package {{.ProxyPackage}}

import (
	"errors"
	"github.com/koofr/go-resourcepool"

	"{{.InterfaceImport}}"
)

var CreateResourceErr = errors.New("{{.ClientType}} resource could not be created")

type ClientFactory func() (*{{.ClientType}}, error)

type resource struct {
	client *{{.ClientType}}
	closed bool
}

func (r *resource) Close() {
	r.closed = true
	r.client.Transport.Close()
}

func (r *resource) IsClosed() bool {
	return r.closed
}

type Proxy struct {
	clientFactory ClientFactory
	pool          *resourcepool.ResourcePool
}

func New(clientFactory ClientFactory, idleCapacity int, maxResources int) *Proxy {
	p := &Proxy{
		clientFactory: clientFactory,
	}

	p.pool = resourcepool.NewResourcePool(p.createResource, idleCapacity, maxResources)

	return p
}

func (p *Proxy) Close() {
	p.pool.Close()
}

func (p *Proxy) createResource() (r resourcepool.Resource, err error) {
	client, err := p.clientFactory()

	if err != nil {
		return
	}

	r = &resource{client, false}

	return
}

func (p *Proxy) getResource() (resourcepool.Resource, error) {
	for i := 0; i < 2; i++ {
		r, err := p.pool.Acquire()

		if err != nil {
			p.pool.Empty()

			continue
		}

		err = r.(*resource).client.Ping()

		if err != nil {
			r.Close()

			p.pool.Release(r)

			p.pool.Empty()

			continue
		}

		return r, nil
	}

	return nil, CreateResourceErr
}

{{range .Functions}}
func (p *Proxy) {{.Name}}({{range .Params}}{{.Name}} {{.Type}}, {{end}})({{range .Res}}{{.Name}} {{.Type}}, {{end}}){
	poolResource, err := p.getResource()

	if err != nil {
		return
	}

	defer p.pool.Release(poolResource)

	return poolResource.(*resource).client.{{.Name}}({{range .Params}}{{.Name}}, {{end}})
}
{{end}}
`

type Generator struct {
	InterfaceImport  string
	InterfacePackage string
	InterfaceName    string
	ProxyPackage     string
	Functions        []gointerfacer.Func
}

type ThriftInterface struct {
	InterfaceImport string
	ProxyPackage    string
	ClientType      string
	Functions       []gointerfacer.Func
}

func NewGenerator(iface string) (g *Generator, err error) {
	ifaceImport, ifacePkg, ifaceName, err := gointerfacer.FindInterface(iface)

	if err != nil {
		return nil, err
	}

	proxyPackage := ifacePkg + "proxy"

	functions, err := gointerfacer.Functions(iface)

	if err != nil {
		return nil, err
	}

	var pingFunc *gointerfacer.Func

	for _, f := range functions {
		if f.Name == "Ping" && len(f.Params) == 0 && len(f.Res) == 1 && f.Res[0].Type == "error" {
			pingFunc = &f
		}
	}

	if pingFunc == nil {
		return nil, fmt.Errorf("Interface %s does not contain function Ping() error", iface)
	}

	g = &Generator{
		InterfaceImport:  ifaceImport,
		InterfacePackage: ifacePkg,
		InterfaceName:    ifaceName,
		ProxyPackage:     proxyPackage,
		Functions:        functions,
	}

	return g, nil
}

func (g *Generator) render() (source []byte, err error) {
	ti := &ThriftInterface{
		InterfaceImport: g.InterfaceImport,
		ProxyPackage:    g.ProxyPackage,
		ClientType:      g.InterfacePackage + "." + g.InterfaceName + "Client",
		Functions:       g.Functions,
	}

	tmpl, err := template.New("tpl").Parse(proxyTemplate)

	if err != nil {
		return nil, err
	}

	buf := &bytes.Buffer{}

	err = tmpl.Execute(buf, ti)

	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (g *Generator) format(source []byte) (code []byte, err error) {
	return format.Source(source)
}

func (g *Generator) Generate() (code []byte, err error) {
	source, err := g.render()

	if err != nil {
		return nil, err
	}

	code, err = g.format(source)

	if err != nil {
		return nil, err
	}

	return code, nil
}
